from xlsx2html import xlsx2html
from bs4 import BeautifulSoup
import csv
import pprint
import html
import os
import conf
import argparse
'''''''''''''''''''''''''''''''''
    Utility functions here
'''''''''''''''''''''''''''''''''

# is the cell valid?
def is_valid_cell(s):
    return s is not None and s.string[0] in conf.valid_chars

# get new cell value from old cell value
def process_cell(td, sheet_name, names):
    id = td['id']
    col = id[len(sheet_name) + 1]
    # calc context
    context = conf.ix_context[col] if col in conf.ix_context else "I20220630"
    try:
        outstring = td.string
        outstring_int = td.string
        if td.string[0] == "$":
            dollar = "$"
            outstring = td.string[1:]
            outstring_int = td.string[1:]
        else:
            dollar = ""
        if outstring[0] == "-":
            minus = "-"
            sign = ' sign="-"'
            outstring = outstring_int[1:]
        else:
            minus = ""
            sign = ""
        if td.string == "-" or td.string == "$ -":
            minus = ""
            sign = ""
            value = ''
            # value = ' value="0"'  -- Arelle throwing error when I use this
            format = 'ixt:fixed-zero'
            outstring = "-"
        else:
            format = 'ixt:num-dot-decimal'
            value = ""
        row = id[(len(sheet_name)+2):]
        
        name = names[row] if row in names else ""

        cell_id = col + row
        content = f'{dollar}{minus}<ix:nonFraction contextRef="{context}" name="{name}" unitRef="USD" id="{cell_id}" decimals="0" format="{format}"{sign}{value}>' + \
            outstring + '</ix:nonFraction>'
        return content
    except Exception as e:
        return None

'''''''''''''''''''''''''''''''''
    Main code here
'''''''''''''''''''''''''''''''''

# Parse command line first
parser = argparse.ArgumentParser()
parser.add_argument('--i', type=str, metavar="input_file(xlsx)", required=True, help="Input xlsx file name")
parser.add_argument('--o', type=str, metavar="output_file(html)", help="Output html file name")

args = parser.parse_args()

if args.i:
    input_file = args.i
if args.o:
    output_file = args.o
else:
    output_file = input_file.split(".")[0] + ".html"

# Load lookup table between account caption names and taxonomy elements
with open(conf.elements_path) as f:
    next(f)  # Skip the header
    reader = csv.reader(f, skipinitialspace=True)
    elements = dict(reader)

# Use xlsx2html library to Convert Excel Worksheet to html
sheet_count = 0
while True:
    try:
        xlsx2html(input_file, f"temp{sheet_count}",sheet=sheet_count)
        sheet_count += 1
    except IndexError:
        break
    except:
        print("File not exists or bad format")
        exit(0)
    
# Because xlsx2html does not right align numeric values, add text-align:right clauses to style attributes for all numbers
# Also use Beautiful Soup to add Inline XBRL ix:nonFraction tags
html_in = ""
for i in range(sheet_count):
    with open(f"temp{i}", 'r') as f:
        html = f.read()

    # Get rid of header generated by the xlsx2html library
    html_trunc = html.replace(conf.original_header, '')

    # Parse html
    soup = BeautifulSoup(html_trunc, 'html.parser')
    names = {}
    sheet_name = None

    for td in soup.find_all('td'):
        id = td['id']
        # Get sheet name
        if sheet_name is None:
            sheet_name = td['id'].split("!")[0]
        # Add text-align to all cells
        if is_valid_cell(td):
            td['style'] = td['style'] + ';text-align:right'
        # Calculate Column
        col = id[len(sheet_name) + 1]
        # Process column A
        if col == 'A':
            caption = pprint.pformat((td.contents)).lower()[2:-2]
            try:
                row = id[(len(sheet_name)+2):]
                names[row] = elements[caption]
            except:
                pass

    # Process column B~
    for td in soup.find_all('td'):
        id = td['id']
        col = id[len(sheet_name) + 1]
        if col != 'A' and is_valid_cell(td):
            content = process_cell(td, sheet_name, names)
            if content:
                td.string = content

    # Replace sheet name if contains space
    if " " in sheet_name:
        for td in soup.find_all('td'):
            id = td['id']
            new_id = id.replace(" ", "").replace("!", "_")
            td['id'] = new_id

    html_in += soup.prettify("utf-8").decode("utf-8")
# Replace default html header tag with the one required for Inline XBRL
html_out = conf.new_header + '\n' + conf.ix_header.replace("$place_id$", conf.place_id) + '\n'

for line in html_in.splitlines():
    html_out = html_out + line + '\n'

# Add closing tags
html_out = html_out + '</body></html>'

# Replace escaped versions of < and > with the real versions and get rid of the string "Sheet1!" from td ids
html_out = html_out.replace("&lt;", "<")
html_out = html_out.replace("&gt;", ">")
html_out = html_out.replace(f"{sheet_name}!", f"{sheet_name}_")

with open(output_file, 'w') as f:
    f.write(html_out)
    print(f"Successfully converted to {output_file}")
# Remove temp file
for i in range(sheet_count):
    os.remove(f"temp{i}")
# Arelle functionality requires downloading and installing Arelle
# These commands are intended to validate and display the processed xbrl file in the Javascript viewer
# os.system('"C:\\Program Files\\Arelle\\arellecmdline" --file=D:\\xlsx2ixbrl\\ca_clayton_2022.html --plugins EdgarRenderer')

# This does not work - the idea is to start Arelle's web server and then view the file in Chrome
# os.system('"C:\\Program Files\\Arelle\\arelleCmdLine" --webserver=localhost:5to check 1053')
# os.system('Start chrome /profile-directory="Default" "http://localhost:51053/1/ix.html?doc=ca_clayton_2022.html&xbrl=true?redline=true"')
